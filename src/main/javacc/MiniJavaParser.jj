options {
  STATIC = false;
  JAVA_UNICODE_ESCAPE = true;
  DEBUG_PARSER = false;
}

/******************************************************************************/
/* PARSER CODE                                                                */
/******************************************************************************/
PARSER_BEGIN(MiniJavaParser)
    package de.keine_arme_keine_kekse.parser;

    import de.keine_arme_keine_kekse.syntaxtree.*;
    import de.keine_arme_keine_kekse.visitor.*;

    public class MiniJavaParser {

}
PARSER_END(MiniJavaParser)


/*******************************************************************************
 * LEXICAL SPECIFICATION
 **************************************************************************** */

/* =============================================================================
 * Definieren Sie hier alle zu ignorierenden Tokens
 * ========================================================================== */

SKIP : {
    /* WHITE SPACES */
    < WHITESPACE: (" " | "\n") >  // DIESE DEFINITION ERGÃ„NZEN !!!

    /* COMMENTS */
}


/* =============================================================================
 * Definieren Sie hier alle MiniJava-Tokens.
/*============================================================================*/
TOKEN : {
    // < LETTER: ~[] >  // DIESE ZEILE ENTFERNEN !!!

    /* RESERVED WORDS */

      < CLASS : "class" >
    | < PUBLIC : "public" >
    | < STATIC : "static" >
    | < VOID : "void" >
    | < EXTENDS : "extends" >
    | < RETURN : "return" >
    | < INT : "int" >
    | < INT_ARRAY : "int[]" >
    | < BOOLEAN : "boolean" >
    | < IF : "if" >
    | < ELSE : "else" >
    | < WHILE : "while" >
    | < TRUE : "true" >
    | < FALSE : "false" >
    | < THIS : "this" >
    | < NEW : "new" >
    | < MAIN : "main" >

    | < STRING : "String" >

    /* INTEGERS */
    | < INTEGER_LITERAL : ["0"-"9"] >

    /* IDENTIFIERS */
    | < IDENTIFIER_LITERAL : "[a-Z][a-Z0-9*]" >

    /* SEPARATORS */
    | < L_PAREN : "(" >
    | < R_PAREN : ")" >
    | < L_BRACE : "{" >
    | < R_BRACE : "}" >
    | < L_BRACKET : "[" >
    | < R_BRACKET : "]" >

    /* OPERATORS */
}

/*******************************************************************************
 * SYNTACTICAL SPECIFICATION
 **************************************************************************** */

Identifier Identifier() : {
    Token lexem;
}{
    lexem=<IDENTIFIER_LITERAL>
    { return new Identifier(lexem.toString()); }
}

MainClass MainClass() : {
    Identifier classId;
    Identifier formalId;
    Statement statement;
}{
    "class" classId=Identifier() "{" "public" "static" "void" "main" "(" "String" "[" "]" formalId=Identifier() ")" "{" statement=Statement() "}" "}"
    {
        return new MainClass(classId, formalId, statement);
    }
}

void ClassDeclSimple(ClassDeclList list) : {
    Identifier classId;
    Identifier parentId=null;
    VarDeclList varList;
    MethodDeclList methodList;
}{
    "class" (classId=Identifier()) ("extends" parentId=Identifier())? "{" varList=VarDeclList() methodList=MethodDeclList() "}"
    {
        if(parentId != null) {
        list.addElement(new ClassDeclExtends(classId, parentId, varList, methodList));
        return;
        }
        list.addElement(new ClassDeclSimple(classId,varList,methodList));
    }
}

VarDeclList VarDeclList(): {
    VarDecl declaration;
    VarDeclList list = new VarDeclList();
}{
    (declaration=VarDecl(){list.addElement(declaration);})*
    {
        return list;
    }
}

VarDecl VarDecl() : {
    Typing type;
    Identifier id;
}{
    type=Typing() id=Identifier()
    {
        return new VarDecl(type, id);
    }
}

Typing Typing() : {
    Token lexem;
} {
    lexem=<INT_ARRAY>|lexem=<BOOLEAN>|lexem=<INT>|lexem=<IDENTIFIER_LITERAL>
    {
        String lexemAsString = lexem.toString();
        if(lexemAsString.equals("int")) {
            return new IntegerTyping();
        } else if(lexemAsString.equals("intarray")) {
            return new IntArrayTyping();
        } else if(lexemAsString.equals("boolean")) {
            return new BooleanTyping();
        } else {
            return new IdentifierTyping(lexemAsString);
        }
    }
}

MethodDeclList MethodDeclList(): {
    MethodDeclList list = new MethodDeclList();
} {
    (MethodDecl(list))*
    {
        return list;
    }
}

void MethodDecl(MethodDeclList list): {
    Typing returnType;
    Identifier methodName;
    FormalList formalList = new FormalList();
    VarDeclList varDeclList;
    StatementList statementList;
    Exp returnExpression;
} {
    "public" returnType=Typing() methodName=Identifier() "(" (formalList=FormalList())? ")" "{" varDeclList=VarDeclList() statementList=StatementList()  "return" returnExpression=Expression() "}"
    {
        list.addElement(new MethodDecl(returnType, methodName, formalList, varDeclList, statementList, returnExpression));
    }
}

FormalList FormalList() : {
    FormalList list = new FormalList();
} {
    Formal(list) ("," Formal(list))*
    {
        return list;
    }
}

void Formal(FormalList list) : {
    Typing type;
    Identifier name;
} {
    type=Typing() name=Identifier()
    {
        list.addElement(new Formal(type, name));
    }
}

ExpList ExpList() : {
    Exp exp;
    ExpList list = new ExpList();
} {
    (exp=Expression(){list.addElement(exp);} ("," Expression(){list.addElement(exp);}))*
    {
        return list;
    }
}

Exp ExpressionR(Exp first) : {
  Exp second;

  Exp array = null;
  Exp index = null;

  Exp object = null;
  Identifier methodId = null;
  ExpList expList = null;

  Token intLexem = null;

  Token idLexem = null;
  Identifier id = null;

  Exp size = null;

  Exp exp = null;
}{
    "&&" second=Expression()
    {
        return new And(first, second);
    }
    |
    "<" second=Expression()
    {
        return new LessThan(first, second);
    }
    |
    "+" second=Expression()
    {
        return new Plus(first, second);
    }
    |
    "-" second=Expression()
    {
        return new Minus(first, second);
    }
    |
    "*" second=Expression()
    {
        return new Times(first, second);
    }
    |
    "[" second=Expression() "]"
    {
        return new ArrayLookup(first, second);
    }
    |
    exp=DotExpression(first)
    {
        return exp;
    }
    |
    intLexem=<INTEGER_LITERAL>
    {
        return new IntegerLiteral(Integer.parseInt(intLexem.toString()));
    }
    |
    idLexem=<IDENTIFIER_LITERAL>
    {
        return new IdentifierExp(idLexem.toString());
    }
    |
    ""
    {
        return exp;
    }
}

Exp UnaryExpression() : {
    Exp exp;
}{
    "false"
    {
        return new False();
    }
    |
    "true"
    {
        return new True();
    }
    |
    "!" exp=Expression()
    {
        return new Not(exp);
    }
    |
    "(" exp=Expression() ")"
    {
        return exp;
    }
    |
    "this"
    {
        return new This();
    }
    |
    exp=NewExpression()
    {
        return exp;
    }
}

Exp NewExpression() : {
    Exp exp;
    Identifier id;
}{
    // TODO: Why is this needed? Without it javacc generates invalid code.
    LOOKAHEAD(2)
    "new" "int" "[" exp=Expression() "]"
    {
        return new NewArray(exp);
    }
    |
    "new" id=Identifier() "()"
    {
        return new NewObject(id);
    }
}

Exp DotExpression(Exp first) : {
    Identifier methodId = null;
    ExpList expList = null;
}{
    // TODO: Why is this needed? Without it javacc generates invalid code.
    LOOKAHEAD(2)
    "." "length"
    {
        return new ArrayLength(first);
    }
    |
    "." methodId=Identifier() "(" (expList=ExpList()) ")"
    {
        return new Call(first, methodId, expList);
    }
}

Exp Expression() : {
    Exp first;
    Exp exp = null;
}{
    first=ExpressionR(null)
    exp=ExpressionR(first)
    {return first;}
    |
    exp=UnaryExpression()
    {
        return exp;
    }

}

Statement Statement() : {
    Statement statement = null;
}{
    LOOKAHEAD(2)
    statement=Block()
    {
        return statement;
    }
    |
    statement=If()
    {
        return statement;
    }
    |
    statement=While()
    {
        return statement;
    }
    |
    statement=Print()
    {
        return statement;
    }
    |
    statement=AssignStatement()
    {
        return statement;
    }
}

Block Block() : {
  StatementList statementList = null;
}{
    "{" statementList=StatementList() "}"
    {
        return new Block(statementList);
    }
}

StatementList StatementList() : {
    Statement statement;
    StatementList list = new StatementList();
}{
    (statement=Statement(){list.addElement(statement);})*
    {
        return list;
    }
}

If If() : {
    Exp exp = null;
    Statement thenStatement = null;
    Statement elseStatement = null;
}{
    "if" "(" exp=Expression() ")" thenStatement=Statement() "else" elseStatement=Statement()
    {
        return new If(exp, thenStatement, elseStatement);
    }
}

While While() : {
    Exp exp = null;
    Statement statement = null;
}{
    "while" "(" exp=Expression() ")" statement=Statement()
    {
        return new While(exp, statement);
    }
}

Print Print() : {
    Exp exp = null;
}{
    "System.out.println" "(" exp=Expression() ")" ";"
    {
        return new Print(exp);
    }
}

Statement AssignStatement() : {
    Statement statement = null;
}{
    // TODO: Why is this needed? Without it javacc generates invalid code.
    LOOKAHEAD(2)
    statement=Assign()
    {
        return statement;
    }
    |
    statement=ArrayAssign()
    {
        return statement;
    }
}

Assign Assign() : {
    Identifier id = null;
    Exp exp = null;
}{
    id=Identifier() "=" exp=Expression() ";"
    {
        return new Assign(id, exp);
    }
}

ArrayAssign ArrayAssign() : {
    Identifier id = null;
    Exp index = null;
    Exp exp = null;
}{
    id=Identifier() "[" index=Expression() "]" "=" exp=Expression() ";"
    {
        return new ArrayAssign(id, index, exp);
    }
}

ClassDeclList ClassDeclList() : {
    ClassDeclList list = new ClassDeclList();
}{
    (ClassDeclSimple(list))*
    {
        return list;
    }
}

Program Program() : {
    MainClass mainClass;
    ClassDeclList classes;
}{
    mainClass=MainClass()
    classes=ClassDeclList()
    <EOF>
    {
        return new Program(mainClass, classes);
    }
}
