options {
  STATIC = false;
  JAVA_UNICODE_ESCAPE = true;
  DEBUG_PARSER = false;
}

/******************************************************************************/
/* PARSER CODE                                                                */
/******************************************************************************/
PARSER_BEGIN(MiniJavaParser)
    package de.keine_arme_keine_kekse.parser;

    import de.keine_arme_keine_kekse.syntaxtree.*;
    import de.keine_arme_keine_kekse.visitor.symboltable.*;

    public class MiniJavaParser {

}
PARSER_END(MiniJavaParser)


/*******************************************************************************
 * LEXICAL SPECIFICATION
 **************************************************************************** */

/* =============================================================================
 * Definieren Sie hier alle zu ignorierenden Tokens                        
 * ========================================================================== */

SKIP : {
    /* WHITE SPACES */
    < WHITESPACE: (" " | "\n") >  // DIESE DEFINITION ERGÃ„NZEN !!!

    /* COMMENTS */
}


/* =============================================================================
 * Definieren Sie hier alle MiniJava-Tokens. 
/*============================================================================*/
TOKEN : {
    // < LETTER: ~[] >  // DIESE ZEILE ENTFERNEN !!!

    /* RESERVED WORDS */

      < CLASS : "class" >
    | < PUBLIC : "public" >
    | < STATIC : "static" >
    | < VOID : "void" >
    | < EXTENDS : "extends" >
    | < RETURN : "return" >
    | < INT : "int" >
    | < INT_ARRAY : "int[]" >
    | < BOOLEAN : "boolean" >
    | < IF : "if" >
    | < ELSE : "else" >
    | < WHILE : "while" >
    | < TRUE : "true" >
    | < FALSE : "false" >
    | < THIS : "this" >
    | < NEW : "new" >
    | < MAIN : "main" >

    | < STRING : "String" >
    
    /* INTEGERS */

    /* IDENTIFIERS */
    | < IDENTIFIER : "[a-Z][a-Z0-9*]" >

    /* SEPARATORS */
    | < L_PAREN : "(" >
    | < R_PAREN : ")" >
    | < L_BRACE : "{" >
    | < R_BRACE : "}" >
    | < L_BRACKET : "[" >
    | < R_BRACKET : "]" >

    /* OPERATORS */
}

/*******************************************************************************
 * SYNTACTICAL SPECIFICATION
 **************************************************************************** */

Identifier Identifier() : {
    Token lexem;
}{
    lexem=<IDENTIFIER>
    { return new Identifier(lexem.toString()); }
}

MainClass MainClass() : {
    Identifier classId;
    Identifier formalId;
    Statement statement;
}{
    "class" classId=Identifier() "{" "public" "static" "void" "main" "(" "String" "[" "]" formalId=Identifier() ")" "{" statement=Statement() "}" "}"
    {
        return new MainClass(classId, formalId, statement);
    }
}

void ClassDeclSimple(ClassDeclList list) : {
    Identifier classId;
    Identifier parentId=null;
    VarDeclList varList;
    MethodDeclList methodList;
}{
    "class" (classId=Identifier()) ("extends" parentId=Identifier())? "{" varList=VarDeclList() methodList=MethodDeclList() "}"
    {
        if(parentId != null) {
        list.addElement(new ClassDeclExtends(classId, parentId, varList, methodList));
        return;
        }
        list.addElement(new ClassDeclSimple(classId,varList,methodList));
    }
}

VarDeclList VarDeclList(): {
    VarDeclList list = new VarDeclList();
}{
    (VarDecl(list))*
    {
        return list;
    }
}

void VarDecl(VarDeclList list) : {
    Typing type;
    Identifier id;
}{
    type=Typing() id=Identifier()
    {
        list.addElement(new VarDecl(type, id));
    }
}

Typing Typing() : {
    Token lexem;
} {
    lexem=<INT_ARRAY>|lexem=<BOOLEAN>|lexem=<INT>|lexem=<IDENTIFIER>
    {
        String lexemAsString = lexem.toString();
        if(lexemAsString.equals("int")) {
            return new IntegerTyping();
        } else if(lexemAsString.equals("intarray")) {
            return new IntArrayTyping();
        } else if(lexemAsString.equals("boolean")) {
            return new BooleanTyping();
        } else {
            return new IdentifierTyping(lexemAsString);
        }
    }
}

MethodDeclList MethodDeclList(): {
    MethodDeclList list = new MethodDeclList();
} {
    (MethodDecl(list))*
    {
        return list;
    }
}

void MethodDecl(MethodDeclList list): {
    Typing returnType;
    Identifier methodName;
    FormalList formalList = new FormalList();
    VarDeclList varDeclList;
    StatementList statementList;
    Exp returnExpression;
} {
    "public" returnType=Typing() methodName=Identifier() "(" (formalList=FormalList())? ")" "{" varDeclList=VarDeclList() statementList=StatementList()  "return" returnExpression=Expression() "}"
    {
        list.addElement(new MethodDecl(returnType, methodName, formalList, varDeclList, statementList, returnExpression));
    }
}

FormalList FormalList() : {
    FormalList list = new FormalList();
} {
    Formal(list) ("," Formal(list))*
    {
        return list;
    }
}

void Formal(FormalList list) : {
    Typing type;
    Identifier name;
} {
    type=Typing() name=Identifier()
    {
        list.addElement(new Formal(type, name));
    }
}

Exp Expression() : {

} {
    "NO match"
    {
        return null;
    }
}

ClassDeclList ClassDeclList() : {
    ClassDeclList list = new ClassDeclList();
}{
    (ClassDeclSimple(list))*
    {
        return list;
    }
}

StatementList StatementList() : {
    Statement statement;
    StatementList list = new StatementList();
} {
    (statement=Statement() {list.addElement(statement);})*
    {
        return list;
    }
}

Statement Statement() : {} {
    "THIS"
    {
        return null;
    }
}

Program Program() : {
    MainClass mainClass;
    ClassDeclList classes; 
}{
    mainClass=MainClass()
    classes=ClassDeclList()
    { 
        return new Program(mainClass, classes); 
    }
}
